import { Location, SerializedLocation } from "./location.js"
import { Token, SerializedToken } from "./token.js"

export interface HerbError {
  message: string;
  location: Location;
}

export interface SerializedError {
  message: string;
  location: SerializedLocation;
}

// TODO: implement
export interface HerbWarning {
  message: string;
  location: Location;
}

// TODO: implement
export interface SerializedWarning {
  message: string;
  location: SerializedLocation;
}

export type NodeType =
  <%- nodes.each_with_index.map do |node, index| -%>
  | "<%= node.type %>"
  <%- end -%>

export type SerializedNodeType = string

export interface SerializedNode {
  type: SerializedNodeType;
  location: SerializedLocation;
  errors: SerializedError[];
}

export interface BaseNodeProps {
  type: NodeType;
  location: Location;
  errors: HerbError[];
}

export abstract class Node {
  readonly type: string;
  readonly location: Location;
  readonly errors: HerbError[];

  static from(node: SerializedNode): Node {
    switch (node.type) {
      <%- nodes.each do |node| -%>
      case "<%= node.type %>": return <%= node.name %>.from(node as Serialized<%= node.name %>);
      <%- end -%>

      default:
        throw new Error(`Unknown node type: ${node.type}`);
    }
  }

  constructor(type: string, location: Location, errors: HerbError[]) {
    this.type = type;
    this.location = location;
    this.errors = errors;
  }

  toJSON(): SerializedNode {
    return {
      type: this.type,
      location: this.location.toJSON(),
      errors: this.errors
    };
  }

  inspect(): string {
    return this.treeInspect(0)
  }

  abstract treeInspect(indent?: number): string;

  protected inspectErrors(options: { prefix: string } = { prefix: "" }): string {
    if (!this.errors || this.errors.length === 0) return "";

    let output = "";
    this.errors.forEach((error, index) => {
      const isLast = index === this.errors.length - 1;
      const symbol = isLast ? "└──" : "├──";
      output += `${options.prefix}${symbol} error: ${error.message}\n`;
    });

    return output;
  }

  protected inspectArray(
    array: any[] | null | undefined,
    options: { prefix: string } = { prefix: "" }
  ): string {
    if (!array) return "∅\n";
    if (array.length === 0) return "[]\n";

    let output = "\n";

    array.forEach((item, index) => {
      const isLast = index === array.length - 1;
      const symbol = isLast ? "└──" : "├──";

      if (item instanceof Node) {
        output += `${options.prefix}${symbol} \n`;
        const childPrefix = isLast ? "    " : "│   ";
        output += item.treeInspect(1).replace(/^/gm, options.prefix + childPrefix).trimStart();
      } else {
        output += `${options.prefix}${symbol} ${item}\n`;
      }
    });

    return output;
  }
}
<%- nodes.each do |node| -%>

export interface Serialized<%= node.name %> {
  type: "<%= node.type %>";
  location: SerializedLocation;
  errors: SerializedError[];
  <%- node.fields.each do |field| -%>
  <%- case field -%>
  <%- when Herb::Template::StringField -%>
  <%= field.name %>: string;
  <%- when Herb::Template::TokenField -%>
  <%= field.name %>: SerializedToken | null;
  <%- when Herb::Template::BooleanField -%>
  <%= field.name %>: boolean;
  <%- when Herb::Template::NodeField -%>
  <%= field.name %>: SerializedNode | null;
  <%- when Herb::Template::ArrayField -%>
  <%= field.name %>: SerializedNode[];
  <%- else -%>
  <%= field.name %>: any; // <%= field.inspect %>
  <%- end -%>
  <%- end -%>
}

export interface <%= node.name %>Props extends BaseNodeProps {
  <%- node.fields.each do |field| -%>
  <%- case field -%>
  <%- when Herb::Template::StringField -%>
  <%= field.name %>: string;
  <%- when Herb::Template::TokenField -%>
  <%= field.name %>: Token | null;
  <%- when Herb::Template::BooleanField -%>
  <%= field.name %>: boolean;
  <%- when Herb::Template::NodeField -%>
  <%= field.name %>: Node | null;
  <%- when Herb::Template::ArrayField -%>
  <%= field.name %>: Node[];
  <%- else -%>
  <%= field.name %>: any; // <%= field.inspect %>
  <%- end -%>
  <%- end -%>
}

export class <%= node.name %> extends Node {
  <%- node.fields.each do |field| -%>
  <%- case field -%>
  <%- when Herb::Template::StringField -%>
  readonly <%= field.name %>: string;
  <%- when Herb::Template::TokenField -%>
  readonly <%= field.name %>: Token | null;
  <%- when Herb::Template::BooleanField -%>
  readonly <%= field.name %>: boolean;
  <%- when Herb::Template::NodeField -%>
  readonly <%= field.name %>: Node | null;
  <%- when Herb::Template::ArrayField -%>
  readonly <%= field.name %>: Node[];
  <%- else -%>
  readonly <%= field.name %>: any;
  <%- end -%>
  <%- end -%>

  static from(data: Serialized<%= node.name %>): <%= node.name %> {
    return new <%= node.name %>({
      type: data.type,
      location: Location.from(data.location),
      errors: data.errors.map(error => ({
        message: error.message,
        location: Location.from(error.location)
      })),
      <%- node.fields.each do |field| -%>
      <%- case field -%>
      <%- when Herb::Template::StringField -%>
      <%= field.name %>: data.<%= field.name %>,
      <%- when Herb::Template::TokenField -%>
      <%= field.name %>: data.<%= field.name %> ? Token.from(data.<%= field.name %>) : null,
      <%- when Herb::Template::BooleanField -%>
      <%= field.name %>: data.<%= field.name %>,
      <%- when Herb::Template::NodeField -%>
      <%= field.name %>: data.<%= field.name %> ? Node.from((data.<%= field.name %> as any)) : null,
      <%- when Herb::Template::ArrayField -%>
      <%= field.name %>: data.<%= field.name %>.map(node => Node.from(node)),
      <%- else -%>
      <%= field.name %>: data.<%= field.name %>,
      <%- end -%>
      <%- end -%>
    })
  }

  constructor(props: <%= node.name %>Props) {
    super(props.type, props.location, props.errors);
    <%- node.fields.each do |field| -%>
    <%- case field -%>
    <%- when Herb::Template::ArrayField -%>
    this.<%= field.name %> = props.<%= field.name %>;
    <%- when Herb::Template::TokenField -%>
    this.<%= field.name %> = props.<%= field.name %>;
    <%- when Herb::Template::NodeField -%>
    this.<%= field.name %> = props.<%= field.name %>
    <%- else -%>
    this.<%= field.name %> = props.<%= field.name %>;
    <%- end -%>
    <%- end -%>
  }

  toJSON(): Serialized<%= node.name %> {
    return {
      ...super.toJSON(),
      type: "<%= node.type %>",
      <%- node.fields.each do |field| -%>
      <%- case field -%>
      <%- when Herb::Template::StringField -%>
      <%= field.name %>: this.<%= field.name %>,
      <%- when Herb::Template::TokenField -%>
      <%= field.name %>: this.<%= field.name %> ? this.<%= field.name %>.toJSON() : null,
      <%- when Herb::Template::BooleanField -%>
      <%= field.name %>: this.<%= field.name %>,
      <%- when Herb::Template::NodeField -%>
      <%= field.name %>: this.<%= field.name %> ? this.<%= field.name %>.toJSON() : null,
      <%- when Herb::Template::ArrayField -%>
      <%= field.name %>: this.<%= field.name %>.map(node => node.toJSON()),
      <%- else -%>
      <%= field.name %>: this.<%= field.name %>,
      <%- end -%>
      <%- end -%>
    };
  }

  treeInspect(indent = 0): string {
    let output = "";

    output += `@ <%= node.name %> ${this.location.treeInspect()}\n`;
    output += this.inspectErrors({ prefix: "<%= node.fields.any? ? "│   " : "    " %>" });

    <%- node.fields.each do |field| -%>
    <%- symbol = node.fields.last == field ? "└──" : "├──" -%>
    <%- name = "#{symbol} #{field.name}: " -%>
    <%- case field -%>
    <%- when Herb::Template::StringField -%>
    output += `<%= name %>${JSON.stringify(this.<%= field.name %>)}\n`;
    <%- when Herb::Template::TokenField -%>
    output += "<%= name %>";
    output += this.<%= field.name %> ? this.<%= field.name %>.treeInspect() : "∅";
    output += "\n";
    <%- when Herb::Template::BooleanField -%>
    output += "<%= name %>";
    output += typeof this.<%= field.name %> === 'boolean' ? String(this.<%= field.name %>) : "∅";
    output += "\n";
    <%- when Herb::Template::NodeField -%>
    output += "<%= name %>";
    if (this.<%= field.name %>) {
      <%- prefix = (node.fields.last == field) ? "    " : "│   " -%>
      output += "\n";
      <%- if (node.fields.last == field) -%>
      output += "    └── ";
      <%- else -%>
      output += "│   └── ";
      <%- end -%>
      const childOutput = this.<%= field.name %>.treeInspect(indent + 1);
      output += childOutput.replace(/^/gm, "    ".repeat(indent + 1)).trimStart().replace(/^/gm, "<%= prefix %>").replace(new RegExp(`^<%= prefix %>`), "");
    } else {
      output += "∅\n";
    }
    <%- when Herb::Template::ArrayField -%>
    output += "<%= name %>";
    output += this.inspectArray(this.<%= field.name %>, { prefix: "<%= (node.fields.last == field) ? "    " : "│   " %>" });
    <%- else -%>
    output += `<%= name %> ${this.<%= field.name %>}\n`;
    <%- end -%>
    <%- end -%>

    output += "\n";

    return output.replace(/^/gm, "    ".repeat(indent));
  }
}
<%- end -%>
